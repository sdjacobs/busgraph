<!DOCTYPE html>
<meta charset="utf-8">
<style>

.stroke {
  fill: none;
  stroke: #000;
  stroke-width: .5;
}


.node {
  stroke: #fff;
  stroke-width: 0.5px;
}

.link {
  stroke: #999;
  stroke-opacity: .6;
}


</style>
<body>
<div id="status"></div>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/d3.geo.tile.v0.min.js"></script>
<script src="d3.mapzoom.js"></script>
<script src="heap.js"></script>
<script src="dijkstra.js"></script>
<script src="matrix.js"></script>
<script>

var width = 900,
  height = 600;

var center = [-87.6847, 41.8369], scale = 70000;

var mapzoom = d3.mapzoom()
  .center(center)
  .scale(scale)

var svg = d3.select("body").append("svg")
  .attr("width", width)
  .attr("height", height)
  .call(mapzoom);

var frame = svg.append("g")

//mapzoom.addTileLayer(frame, "tiles.mapbox.com/v3/examples.map-zr0njcqy/", "abcd");


function parseStops_(stops, D, id2index) {
  stops.forEach(function(s) {
    s.departure_time = s.departure_time.split(':').map(parseFloat);
    s.arrival_time = s.arrival_time.split(':').map(parseFloat);
  });
  var tid, currentStops, prev;
  var links = [];

  for (var i = 0; i < stops.length; i++) {
    
    var s = stops[i];
    if (s.trip_id != tid) {
      tid = s.trip_id;
      currentStops = [];
      prev = s;
      continue;
    }
  }
}


function parseTrips(trips) {
  

  var tripsByStop = {};
   
    for (var i = 0; i < trips.length; i++) {
      
      var t = trips[i];
      if (!tripsByStop[t.stop_id])
        tripsByStop[t.stop_id] = [t];
      else 
        tripsByStop[t.stop_id].push(t);
    
      t.index = i;

      if (i+1 < trips.length && t.trip_id == trips[i+1].trip_id)
          t.next = trips[i+1];


    }
    return tripsByStop;
}

/* in minutes */
function timediff(a, b) {
  return (b[0] - a[0]) * 60 + (b[1] - a[1]) + (b[2] - a[2])/60;
}

function tripdiff(x, y) {
  var xx = x.arrival_time.split(':').map(parseFloat);
  var yy = y.departure_time.split(':').map(parseFloat);
  return timediff(xx, yy);
}


d3.csv("stops.txt", function(nodes) { 

  var projection = mapzoom.projection(), 
    nodesByID = {}
  
  nodes.forEach(function(d, i) {
    d.coord = [+d.stop_lon, +d.stop_lat]
    nodesByID[d.stop_id] = d;
    d.index = i;
  });

  var node = svg.append("g").selectAll(".node")
    .data(nodes)
     .enter().append("circle")
     .attr("class", "node")
    .attr("r", 2)
    .attr("fill", "grey")
    
  node
    .append("title")
    .text(function(d) { return d.stop_desc })

  mapzoom.addLayer(function() {
    node
      .each(function(d) { d.proj = projection(d.coord); })
      .attr("transform", function(d) { return "translate(" + d.proj + ")" }) 
  });
    
  node.each(function(d) {
    d.selection = d3.select(this);
  });

  node.on("mouseover", function(d) {
    d3.select(this)
    .attr("r", 5)
  });

  node.on("mouseout", function(d) {
    node.attr("r", 2)
  });

  var color = d3.scale.linear()
    .domain([0, 10])
    .range(["green", "yellow"]);  
   

  //var D = matrix(nodes.length, nodes.length, Infinity);
  //parseStops(stoptimes, D);

  var tripsByStop, trips;
  
  d3.csv("stop_times_8.txt", function(data) {
    trips = data;
    tripsByStop = parseTrips(trips); 
  });

  var quadtree = d3.geom.quadtree()
    .x(function(d) { return d.coord[0] })
    .y(function(d) { return d.coord[1] })
   
  var root = quadtree(nodes);

  /* How do you update a node? */
  /* For all neighbors n, if n has not been visited, set D(n) = min(D(n), D through current node */
  var updated = 0; 
  function update(current, unvisited) {
    
    updated++;
    
    var mytrips = tripsByStop[current.stop_id];//.map(function(t) { return trips[t.index + 1]; });
    
    if (!mytrips)
      return;
    for (var i = 0; i < mytrips.length; i++) {
      var trip = mytrips[i];
      if (!trip)
          continue;
      
      var explore = d3.dispatch("stop");
      
      function tick() {
        var next = trip.next;    
        if (next == undefined)
            return true;

        var stop = nodesByID[next.stop_id]

        if (stop.visited)
            return true;
        stop.distance = Math.min(stop.distance, current.distance + tripdiff(trip, next));
        unvisited.updateItem(stop);
      
        trip.next = undefined; /* We've visited this trip */  
        trip = next;

        explore.stop(stop);

        return (trip.next == undefined);
      }

      explore.on("stop", function(d) {
        d.selection.style("fill", "blue");
      });

      d3.timer(tick);
      //while (!tick());
          
    }

    var cx = current.coord[0], cy = current.coord[1], delta = 1;
    root.visit(function(d, x1, y1, x2, y2) { 
      var m = pointRectDist(cx, cy, x1, y1, x2-x1, y2-y1);
      var insquare = cx > x1 && cx < x2 && cy > y1 && cy < y2;
      if (d.leaf && m < delta && !d.point.visited) {
        d.point.distance = Math.min(d.point.distance, current.distance + m * 90); // m mi * 90 min/mi (crawling as the crow flies!)
        unvisited.updateItem(d.point);
      }
      return !insquare && m >= delta;
    });

  }

  var dijkstra = d3.dijkstra()
      .nodes(nodes)
      .update(update);
 
  var color = d3.scale.linear()
    .domain([0, 45, 90])
    .range(["green", "yellow", "red"]);

  dijkstra.on("tick", function() {
      node.style("fill", function(d) { return color(d.distance); });
  });

  dijkstra.on("end", function() {
    var name = dijkstra.source().name;
    node.select("title")
        .text(function(d) { return d.name + "\n(" + d.distance + " miles from " + name + ")" });
  });

  node.on("click", dijkstra.start);
    
});
    
function pointRectDist (px, py, rx, ry, rwidth, rheight)
{
  var cx = Math.max(Math.min(px, rx+rwidth ), rx);
  var cy = Math.max(Math.min(py, ry+rheight), ry);
  return haversine(cx, cy, px, py);
}

// http://stackoverflow.com/questions/15736995/how-can-i-quickly-estimate-the-distance-between-two-latitude-longitude-points
function haversine(lon1, lat1, lon2, lat2) {
  var deg2rad = function(x) { return x * Math.PI / 180 };
  lon1 = deg2rad(lon1);
  lat1 = deg2rad(lat1);
  lon2 = deg2rad(lon2);
  lat2 = deg2rad(lat2);
  dlon = lon2 - lon1 
  dlat = lat2 - lat1 
  a = Math.pow(Math.sin(dlat/2),2) + Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin(dlon/2), 2)
  c = 2 * Math.asin(Math.sqrt(a)) 
  mi = 3956 * c
  return mi
}


</script>

