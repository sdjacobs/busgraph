<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node {
  stroke: #fff;
  stroke-width: 0.5px;
}

</style>
<body>
<div id="status"></div>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/d3.geo.tile.v0.min.js"></script>
<script src="d3.mapzoom.js"></script>
<script src="heap.js"></script>
<script src="dijkstra.js"></script>
<script src="matrix.js"></script>
<script>

/* 
   TODO: * try out canvas
         * add time feature
         * add legend 8:00-9:00
         * trip recovery
*/

var width = 900,
  height = 600;

var center = [-87.6847, 41.8369], scale = 70000;

var mapzoom = d3.mapzoom()
  .center(center)
  .scale(scale)

var svg = d3.select("body").append("svg")
  .attr("width", width)
  .attr("height", height)
  .call(mapzoom);

var frame = svg.append("g")

mapzoom.addTileLayer(frame, "tiles.mapbox.com/v3/examples.map-zr0njcqy/", "abcd");

function parseTrips(trips) {
  
  var tripsByStop = {};
   
  for (var i = 0; i < trips.length; i++) {
      
    var t = trips[i];
    if (!tripsByStop[t.stop_id])
      tripsByStop[t.stop_id] = [t];
    else 
      tripsByStop[t.stop_id].push(t);
    
    if (i+1 < trips.length && t.trip_id == trips[i+1].trip_id)
      t.next = trips[i+1];
  }
  
  return tripsByStop;
}

function tripdiff(x, y) {
  var a = x.arrival_time.split(':').map(parseFloat);
  var b = y.departure_time.split(':').map(parseFloat);
  return (b[0] - a[0]) * 60 + (b[1] - a[1]) + (b[2] - a[2])/60;
}

function getMinutes(x) {
    var xm = x.split(':').map(parseFloat)
    return xm[1] + (xm[2]/60)
}

d3.csv("stops.txt", function(stops) { 

  var projection = mapzoom.projection(), 
    stopsByID = {}
  
  stops.forEach(function(d, i) {
    d.coord = [+d.stop_lon, +d.stop_lat]
    stopsByID[d.stop_id] = d;
  });

  var node = svg.append("g").selectAll(".node")
    .data(stops)
     .enter().append("circle")
     .attr("class", "node")
    .attr("r", 2)
    .attr("fill", "grey")
    
  node
    .append("title")
    .text(function(d) { return d.stop_desc })

  mapzoom.addLayer(function() {
    node
      .each(function(d) { d.proj = projection(d.coord); })
      .attr("transform", function(d) { return "translate(" + d.proj + ")" }) 
  });
    
  node.each(function(d) {
    d.selection = d3.select(this);
  });

  node.on("mouseover", function(d) {
    d3.select(this)
        .attr("r", 5)
  });

  node.on("mouseout", function(d) {
    node.attr("r", 2)
  });

  var tripsByStop, trips; /* These variables are populated asynchronously (but not used til click) */
  
  d3.csv("stop_times_8.txt", function(data) {
    trips = data;
    tripsByStop = parseTrips(trips); 
  });

  var quadtree = d3.geom.quadtree()
    .x(function(d) { return d.coord[0] })
    .y(function(d) { return d.coord[1] })
   
  var root = quadtree(stops);

  var dijkstra = d3.dijkstra()
      .nodes(stops)
      .update(update); /* Custom node updating function */
 
  var color = d3.scale.linear()
    .domain([0, 30, 60])
    .range(["green", "yellow", "red"]);

  //dijkstra.on("tick", function() {
  //    node.style("fill", function(d) { return color(d.distance); });
  //});

  dijkstra.on("end", function() {
    var name = dijkstra.source().name;
    node.select("title")
        .text(function(d) { return d.name + "\n(" + d.distance + " miles from " + name + ")" });
  });

  node.on("click", function(d) {
    var content = d3.select("body").append("div")
    content.append("div").html("<b>Start:</b> " + d.stop_desc);
    content = content.append("div")
    node.on("click", function(dst) {
        content.selectAll("div").remove();
        var src = dst, trips = [];
        content.append("div").html("<b>End:</b> " + dst.stop_desc);

        while(src.prev) {
          trips.unshift(src);
          src = src.prev.stop;
        }
        content.append("div")
            .selectAll("div")
            .data(trips).enter()
            .append("div")
            .html(function(d, i) {
               var p = d.prev.stop
               var m = d.distance - p.distance
               console.log(d.prev.data)
               return "<i>" + p.stop_name + "</i> to <i>" + d.stop_name + "</i> via " + d.prev.mode + " (" + p.distance + " to " + d.distance +")" 
            });
    });

    dijkstra.start(d);
  });


  /* How do you update a node? */
  /* For all neighbors n, if n has not been visited, set D(n) = min(D(n), D through current node */
  function update(current, unvisited) {
    
    /* First, check neighbors reachable by CTA */
    var mytrips = tripsByStop[current.stop_id];
    

    if (!mytrips)
      return;
    for (var i = 0; i < mytrips.length; i++) {
      var start = mytrips[i], curr = start;

      if (!start)
          continue;
      
      var depart = getMinutes(start.departure_time);
      if (depart < current.distance)
          continue;
      
      while(1) {
        var next = curr.next;    
        if (next == undefined)
            break;

        var stop = stopsByID[next.stop_id]

        if (stop.visited)
            break;
    
        /*
        if ((+next.stop_sequence - +start.stop_sequence) > 35) {
        console.log(start)
        console.log(next)
        console.log(tripdiff(start, next))
        thunk()
        }
        */

        var arrival = getMinutes(next.arrival_time);
        if (arrival < stop.distance) {
            stop.distance = arrival;
            /* Current -> Wait -> Stop */
            var wait = {distance: depart, prev: {mode: "wait", stop: current} } // ghost node!
            stop.prev = {mode: "CTA", data: curr, stop: wait}
            unvisited.updateItem(stop);
            stop.selection.style("fill", color(stop.distance));
        }
        //trip.next = undefined; /* We've visited this trip */  
        
        curr = next;

      }

          
    }

    /* Now, any walkable neighbors? */
    var cx = current.coord[0], cy = current.coord[1], delta = 1;
    root.visit(function(d, x1, y1, x2, y2) { 
      var m = pointRectDist(cx, cy, x1, y1, x2-x1, y2-y1);
      var insquare = cx > x1 && cx < x2 && cy > y1 && cy < y2;
      if (d.leaf && m < delta && !d.point.visited) {
        var stop = d.point;
        var dist = current.distance + m * 60; // m mi * 60 min/mi (crawling as the crow flies!)
        if (dist < stop.distance) {
          stop.distance = dist;
          stop.prev = {mode: "walk", data: m, stop: current}
          unvisited.updateItem(stop);
          stop.selection.style("fill", color(stop.distance));
        }
      }
      return !insquare && m >= delta;
    });

  }
    
});
    
function pointRectDist (px, py, rx, ry, rwidth, rheight)
{
  var cx = Math.max(Math.min(px, rx+rwidth ), rx);
  var cy = Math.max(Math.min(py, ry+rheight), ry);
  return haversine(cx, cy, px, py);
}

// http://stackoverflow.com/questions/15736995/how-can-i-quickly-estimate-the-distance-between-two-latitude-longitude-points
function haversine(lon1, lat1, lon2, lat2) {
  var deg2rad = function(x) { return x * Math.PI / 180 };
  lon1 = deg2rad(lon1);
  lat1 = deg2rad(lat1);
  lon2 = deg2rad(lon2);
  lat2 = deg2rad(lat2);
  dlon = lon2 - lon1 
  dlat = lat2 - lat1 
  a = Math.pow(Math.sin(dlat/2),2) + Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin(dlon/2), 2)
  c = 2 * Math.asin(Math.sqrt(a)) 
  mi = 3956 * c
  return mi
}


</script>

