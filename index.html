<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node {
  stroke: #fff;
  stroke-width: 0.5px;
}

</style>
<body>
<div id="status"></div>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/d3.geo.tile.v0.min.js"></script>
<script src="d3.mapzoom.js"></script>
<script src="heap.js"></script>
<script src="dijkstra.js"></script>
<script src="matrix.js"></script>
<script>

/* 
   TODO: * try out canvas
         * add time feature
         * add legend 8:00-9:00
*/

var width = 900,
  height = 600;

var center = [-87.6847, 41.8369], scale = 70000;

var mapzoom = d3.mapzoom()
  .center(center)
  .scale(scale)

var svg = d3.select("body").append("svg")
  .attr("width", width)
  .attr("height", height)
  .call(mapzoom);

var frame = svg.append("g")

mapzoom.addTileLayer(frame, "tiles.mapbox.com/v3/examples.map-zr0njcqy/", "abcd");

function parseTrips(trips) {
  
  var tripsByStop = {};
   
  for (var i = 0; i < trips.length; i++) {
      
    var t = trips[i];
    if (!tripsByStop[t.stop_id])
      tripsByStop[t.stop_id] = [t];
    else 
      tripsByStop[t.stop_id].push(t);
    
    if (i+1 < trips.length && t.trip_id == trips[i+1].trip_id)
      t.next = trips[i+1];
  }
  
  return tripsByStop;
}

function tripdiff(x, y) {
  var a = x.arrival_time.split(':').map(parseFloat);
  var b = y.departure_time.split(':').map(parseFloat);
  return (b[0] - a[0]) * 60 + (b[1] - a[1]) + (b[2] - a[2])/60;
}

d3.csv("stops.txt", function(stops) { 

  var projection = mapzoom.projection(), 
    stopsByID = {}
  
  stops.forEach(function(d, i) {
    d.coord = [+d.stop_lon, +d.stop_lat]
    stopsByID[d.stop_id] = d;
  });

  var node = svg.append("g").selectAll(".node")
    .data(stops)
     .enter().append("circle")
     .attr("class", "node")
    .attr("r", 2)
    .attr("fill", "grey")
    
  node
    .append("title")
    .text(function(d) { return d.stop_desc })

  mapzoom.addLayer(function() {
    node
      .each(function(d) { d.proj = projection(d.coord); })
      .attr("transform", function(d) { return "translate(" + d.proj + ")" }) 
  });
    
  node.each(function(d) {
    d.selection = d3.select(this);
  });

  node.on("mouseover", function(d) {
    d3.select(this)
        .attr("r", 5)
  });

  node.on("mouseout", function(d) {
    node.attr("r", 2)
  });

  var tripsByStop, trips; /* These variables are populated asynchronously (but not used til click) */
  
  d3.csv("stop_times_8.txt", function(data) {
    trips = data;
    tripsByStop = parseTrips(trips); 
  });

  var quadtree = d3.geom.quadtree()
    .x(function(d) { return d.coord[0] })
    .y(function(d) { return d.coord[1] })
   
  var root = quadtree(stops);

  var dijkstra = d3.dijkstra()
      .nodes(stops)
      .update(update); /* Custom node updating function */
 
  var color = d3.scale.linear()
    .domain([0, 45, 90])
    .range(["green", "yellow", "red"]);

  //dijkstra.on("tick", function() {
  //    node.style("fill", function(d) { return color(d.distance); });
  //});

  dijkstra.on("end", function() {
    var name = dijkstra.source().name;
    node.select("title")
        .text(function(d) { return d.name + "\n(" + d.distance + " miles from " + name + ")" });
  });

  node.on("click", dijkstra.start);


  /* How do you update a node? */
  /* For all neighbors n, if n has not been visited, set D(n) = min(D(n), D through current node */
  function update(current, unvisited) {
    
    /* First, check neighbors reachable by CTA */
    var mytrips = tripsByStop[current.stop_id];
    
    if (!mytrips)
      return;
    for (var i = 0; i < mytrips.length; i++) {
      var trip = mytrips[i];
      if (!trip)
          continue;
      
      function explorestop() {
        var next = trip.next;    
        if (next == undefined)
            return true;

        var stop = stopsByID[next.stop_id]

        if (stop.visited)
            return true;
        stop.distance = Math.min(stop.distance, current.distance + tripdiff(trip, next));
        unvisited.updateItem(stop);
        stop.selection.style("fill", color(stop.distance));

        //trip.next = undefined; /* We've visited this trip */  
        trip = next;


        return (trip.next == undefined);
      }

      while (!explorestop()); /* This allows us to give up the runloop so we don't time out. */ 
          
    }

    /* Now, any walkable neighbors? */
    var cx = current.coord[0], cy = current.coord[1], delta = 1;
    root.visit(function(d, x1, y1, x2, y2) { 
      var m = pointRectDist(cx, cy, x1, y1, x2-x1, y2-y1);
      var insquare = cx > x1 && cx < x2 && cy > y1 && cy < y2;
      if (d.leaf && m < delta && !d.point.visited) {
        var stop = d.point;
        stop.distance = Math.min(d.point.distance, current.distance + m * 60); // m mi * 60 min/mi (crawling as the crow flies!)
        unvisited.updateItem(stop);
        stop.selection.style("fill", color(stop.distance));
      }
      return !insquare && m >= delta;
    });

  }
    
});
    
function pointRectDist (px, py, rx, ry, rwidth, rheight)
{
  var cx = Math.max(Math.min(px, rx+rwidth ), rx);
  var cy = Math.max(Math.min(py, ry+rheight), ry);
  return haversine(cx, cy, px, py);
}

// http://stackoverflow.com/questions/15736995/how-can-i-quickly-estimate-the-distance-between-two-latitude-longitude-points
function haversine(lon1, lat1, lon2, lat2) {
  var deg2rad = function(x) { return x * Math.PI / 180 };
  lon1 = deg2rad(lon1);
  lat1 = deg2rad(lat1);
  lon2 = deg2rad(lon2);
  lat2 = deg2rad(lat2);
  dlon = lon2 - lon1 
  dlat = lat2 - lat1 
  a = Math.pow(Math.sin(dlat/2),2) + Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin(dlon/2), 2)
  c = 2 * Math.asin(Math.sqrt(a)) 
  mi = 3956 * c
  return mi
}


</script>

