<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node {
  stroke: #fff;
  stroke-width: 0.5px;
}

span.mode {
    color: red;
}

span.stop {
    color: blue;
}

span.route {
    color: green;
}

.axis path {
    display: none;
}

.axis line {
    stroke: #fff;
}

.axis text {
    fill: white;
}

#viz {
    float: left;
    width: 60%;
    margin: 1%;
}

#content {
    float: left;
    width: 30%;
    margin: 2%;
}

#readme {
    width: 80%;
    overflow: hidden;
    margin: 10%;
    clear: left;
}

h1 {
    margin-left: 1%;
}

body {
    font-family: Arial;
    background: none repeat scroll 0% 0% #F2F2F2;
}

</style>
<title>Dijkstra takes the bus</title>
<body>
<h1>Dijkstra takes the bus</h1>
<div id="viz"></div>
<div id="content"></div>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/d3.geo.tile.v0.min.js"></script>
<script src="d3.mapzoom.js"></script>
<script src="heap.js"></script>
<script src="dijkstra.js"></script>
<script>

var width = parseInt(d3.select("#viz").style("width")),
  height = 500;

var center = [-87.5, 41.87], scale = 70000;
  
var color = d3.scale.linear()
  .domain([0, 40, 80])
  .range(["green", "yellow", "red"]);
var mapzoom = d3.mapzoom()
  .center(center)
  .scale(scale)

var svg = d3.select("#viz").append("svg")
  .attr("width", width)
  .attr("height", height)
  .call(mapzoom);

var frame = svg.append("g")

mapzoom.addTileLayer(frame, "tiles.mapbox.com/v3/examples.map-zr0njcqy/", "abcd");

var routeByTrip = {}
d3.csv("routes.txt", function(routes) {
  var routeByID = {}
  routes.forEach(function(d) {
    routeByID[d.route_id] = d.route_short_name + " " + d.route_long_name;
  });
  
  d3.csv("trips.txt", function(trips) {
    trips.forEach(function(d) {
        routeByTrip[d.trip_id] = routeByID[d.route_id] + " (" + d.direction + ")";
    });
  });
});

d3.csv("stops.txt", function(stops) { 

  var projection = mapzoom.projection(), 
    stopsByID = {}
  
  stops.forEach(function(d, i) {
    d.coord = [+d.stop_lon, +d.stop_lat]
    stopsByID[d.stop_id] = d;
  });

  var node = svg.append("g").selectAll(".node")
    .data(stops)
     .enter().append("circle")
     .attr("class", "node")
    .attr("r", 2)
    .attr("fill", "grey")
    
  node
    .append("title")
    .text(function(d) { return d.stop_desc || d.stop_name })

  mapzoom.addLayer(function() {
    node
      .each(function(d) { d.proj = projection(d.coord); })
      .attr("transform", function(d) { return "translate(" + d.proj + ")" }) 
  });
    
  node.each(function(d) {
    d.selection = d3.select(this);
  });

  node.on("mouseover", function(d) {
    d3.select(this)
        .attr("r", 5)
  });

  node.on("mouseout", function(d) {
    node.attr("r", 2)
  });

  var tripsByStop, trips; /* These variables are populated asynchronously (but not used til click) */
  
  d3.csv("stop_times_8.txt", function(data) {
    trips = data;
    tripsByStop = parseTrips(trips); 
  });

  var quadtree = d3.geom.quadtree()
    .x(function(d) { return d.coord[0] })
    .y(function(d) { return d.coord[1] })
   
  var root = quadtree(stops);

  var dijkstra = d3.dijkstra()
      .nodes(stops)
      .update(update); /* Custom node updating function */

  var progress = legend.append("rect")
      .attr({width: 0, height: 10, x: 20, y: 50, style: "fill:white;"})
  var wscale = d3.scale.linear()
    .domain([1, stops.length])
    .range([1, 200])
  var i = 1;
  dijkstra.on("tick", function() {
    progress.attr("width", wscale(i++));
  });

  dijkstra.on("end", function() {
    var name = dijkstra.source().stop_name;
    node.select("title")
        .text(function(d) { return (d.stop_desc || d.stop_name) + "\n(" + d.distance + " min from " + name + ")" });
    progress.transition().attr("width", 200);
  });

  node.on("click", function(d) {
    var content = d3.select("#content")
    content.append("div").html("<b>Start:</b> " + d.stop_desc);
    content = content.append("div")
    node.on("click", function(dst) {
        content.selectAll("div").remove();
        var src = dst, trips = [];
        content.append("div").html("<b>End:</b> " + dst.stop_desc);

        while(src.prev) {
          trips.unshift(src);
          src = src.prev.stop;
        }

        content.append("div").append("ul")
            .selectAll("li")
            .data(trips).enter()
            .append("li")
            .html(printNode)
    });

    dijkstra.start(d);
  });


  /* How do you update a node? */
  /* For all neighbors n, if n has not been visited, set D(n) = min(D(n), D through current node */
  function update(current, unvisited) {
    
    /* First, check neighbors reachable by CTA */
    var mytrips = tripsByStop[current.stop_id];
    

    if (!mytrips)
      return;
    for (var i = 0; i < mytrips.length; i++) {
      var start = mytrips[i], curr = start;
      if (!start)
          continue;
      var depart = getMinutes(start.departure_time);
      if (depart < current.distance)
          continue;
      
      /* Check from here to the end of the line */
      while(1) {
        var next = curr.next;    
        if (next == undefined)
            break;

        var stop = stopsByID[next.stop_id]

        if (stop.visited)
            break;
    
        var arrival = getMinutes(next.arrival_time);
        if (arrival < stop.distance) {
            stop.distance = arrival;
            /* Current -> Wait -> Stop */
            var wait = {distance: depart, stop_name: current.stop_name, prev: {mode: "wait", stop: current} } // ghost node!
            stop.prev = {mode: "CTA", data: curr, stop: wait}
            unvisited.updateItem(stop);
            stop.selection.style("fill", color(stop.distance));
        }
        curr = next;
      }
    }

    /* Now, any walkable neighbors? */
    var cx = current.coord[0], cy = current.coord[1], delta = 1;
    root.visit(function(d, x1, y1, x2, y2) { 
      var m = pointRectDist(cx, cy, x1, y1, x2-x1, y2-y1);
      var insquare = cx > x1 && cx < x2 && cy > y1 && cy < y2;
      if (d.leaf && m < delta && !d.point.visited) {
        var stop = d.point;
        var dist = current.distance + m * 30; // m mi * 30 min/mi (crawling as the crow flies!)
        if (dist < stop.distance && dist < 80) { /* Just give up at 9:20. No more walking. */
          stop.distance = dist;
          stop.prev = {mode: "walk", data: m, stop: current}
          if (current.prev && current.prev.mode == "walk") {
            stop.prev.data += current.prev.data
            stop.prev.stop = current.prev.stop
          }
          unvisited.updateItem(stop);
          stop.selection.style("fill", color(stop.distance));
        }
      }
      return !insquare && m >= delta;
    });

  }
    
});

/* Legend */

var lw = 200, lh=20, padding=20,
    ltop = svg.node().getBoundingClientRect().top;

var legend = d3.select("body")
  .append("svg")
  .style({"position":"absolute","top":(ltop+30)+"px","left":(width-lw-2*padding)+"px"})
  .attr("width", lw+2*padding)
  
legend.append("linearGradient")
    .attr({"id":"grad", "x1": "0%", "y1": "0%", "x2":"100%", "y2":"0%"})
    .selectAll("stop")
    .data([0, 40, 80]).enter()
    .append("stop")
    .attr("offset", function(d) { return (d*5/4)+"%" })
    .style("stop-opacity", "1")
    .style("stop-color", color)


legend.append("rect")
  .attr("width", lw)
  .attr("height", lh)
  .attr("x", padding)
  .style("fill", "url(#grad)")


var lscale = d3.scale.linear()
  .domain([0, 80])
  .range([0, lw])

var format = (function() {
  var time = d3.time.format("%H:%M");
  var scale = d3.scale.linear().domain([0,80]).range([new Date(0,0,0,8), new Date(0,0,0,9,20)]);
  function formatter(d) { 
      var x = scale(d),
          y = time(new Date(x))
      return y;
  }
  return formatter;
})();

var axis = d3.svg.axis()
  .scale(lscale)
  .ticks(3)
  .tickFormat(format);

legend.append("g")
  .attr("class", "axis")
    .attr("transform", "translate(" + padding + "," + lh +")")
    .call(axis);


/* Utility functions */

function parseTrips(trips) {
  
  var tripsByStop = {};
   
  for (var i = 0; i < trips.length; i++) {
      
    var t = trips[i];
    if (!tripsByStop[t.stop_id])
      tripsByStop[t.stop_id] = [t];
    else 
      tripsByStop[t.stop_id].push(t);
    
    if (i+1 < trips.length && t.trip_id == trips[i+1].trip_id)
      t.next = trips[i+1];
  }
  
  return tripsByStop;
}

function getMinutes(x) {
    var xm = x.split(':').map(parseFloat)
    return xm[1] + (xm[2]/60)
}

function printNode(d) {
  var fmt = format;
  var p = d.prev.stop

  if (d.prev.mode == "walk")
      return "<span class='mode'>Walk</span> from <span class='stop'>" + p.stop_name + "</span> to <span class='stop'>" + d.stop_name + "</span>  (" + fmt(p.distance) + " to " + fmt(d.distance) +")";
  else if (d.prev.mode == "CTA")
      return "<span class='stop'>" + p.stop_name + "</span> to <span class='stop'>" + d.stop_name + "</span> via <span class='route'>" + routeByTrip[d.prev.data.trip_id] + "</span> (" + fmt(p.distance) + " to " + fmt(d.distance) +")"
  else if (d.prev.mode == "wait")
      return "<span class='mode'>Wait</span> at " + d.stop_name + " until " + fmt(d.distance);
}


function pointRectDist (px, py, rx, ry, rwidth, rheight)
{
  var cx = Math.max(Math.min(px, rx+rwidth ), rx);
  var cy = Math.max(Math.min(py, ry+rheight), ry);
  return haversine(cx, cy, px, py);
}

// http://stackoverflow.com/questions/15736995/how-can-i-quickly-estimate-the-distance-between-two-latitude-longitude-points
function haversine(lon1, lat1, lon2, lat2) {
  var deg2rad = function(x) { return x * Math.PI / 180 };
  lon1 = deg2rad(lon1);
  lat1 = deg2rad(lat1);
  lon2 = deg2rad(lon2);
  lat2 = deg2rad(lat2);
  dlon = lon2 - lon1 
  dlat = lat2 - lat1 
  a = Math.pow(Math.sin(dlat/2),2) + Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin(dlon/2), 2)
  c = 2 * Math.asin(Math.sqrt(a)) 
  mi = 3956 * c
  return mi
}



</script>

<div id="readme">

<p>What am I seeing here?</p>

<p>First of all, it's a map of Chicago. Each dot is a CTA stop. Click a dot. Now, you're computing all the distances from that dot, using <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra's algorithm</a>, a classic algorithm in computer science. Dijkstra's algorithm is a way to iteratively discover the shortest paths in a graph, given a starting point.</p>

<p>The result of computing the algorithm is an <a href="http://www.citylab.com/commute/2015/02/every-city-should-have-something-like-san-franciscos-mass-transit-access-map/385336/">access map</a> -- a view into how much of the city you can reach in a given amount of time. But unlike a normal access map, where you'd almost certainly precompute all possible paths, the <em>process</em> of computing is given the same emphasis as the <em>result</em>. The data is almost entirely unprocessed from what's supplied by the CTA, and all the computation happens in your browser (I've found that Google Chrome works the best). I make no guarantees for the real-world accuracy of this information -- so, please use this page to understand Dijkstra and to see a pretty picture of Chicago, but not as a trip planner!</p>

<p>Click a node on the map to start Dijkstra's algorithm from that point. After the computation begins, click another node to see the current shortest path. Colors expand outward as the algorithm explores the network of bus stops in the city, finding paths and updating them. Distance, in this case, means <em>time</em>: starting from my house at 8:00am on a weekday, where can I get to in the next hour?</p>

<h4>Data</h4>

<p>The data comes from the CTA's General Transit Feed Specification, available <a href="http://www.transitchicago.com/developers/gtfs.aspx">here</a>:</p>

<ul>
<li><a href="stops.txt">stops.txt</a>: list of bus and train stops</li>
<li><b>stop_times.txt</b>: scheduled arrival times and departure times for every stop</li>
<li><a href="routes.txt">routes.txt</a>: list of CTA routes</li>
<li><a href="trips.txt">trips.txt</a>: list of CTA trips.</li>
</ul>

<p>"routes.txt" and "trips.txt" are not strictly required for the algorithm; they just allow us to map trip IDs like "440081069971" to human-readable route names like "50 Damen".</p>

<p>Unedited, "stop_times.txt" has over 3 million entries and is 182 MB. This is just too big for a web app-style presentation, so I cut it down to all trips with arrivals between 8:00am and 9:00am (<a href="stop_times_8.txt">stop_times_8.txt</a>).</p>

<h4>Algorithm</h4>

<p>Each node on the map is a transit stop listed in "stops.txt". A node's neighbors can be stops that are further along on a route, or bus stops that are "walking distance." I'm using a dumb appoximation for the amount of time to walk somewhere -- we calculate the distance between two points, as the crow flies, and then say we can walk that at 2 mph. Stops are only walkable if they're within a mile of each other.</p>

<h4>More...</h4>

<p>This project is built with <a href="https://d3js.org">D3</a> and <a href="https://www.npmjs.com/package/heap">heap</a>, a Javascript priority queue implementation. It builds on my <a href="http://bl.ocks.org/sdjacobs/9ce5fadce234497dc592">d3-mapzoom</a> plugin, and my experiments with D3/Dijkstra implementations <a href="http://bl.ocks.org/sdjacobs/3900867adc06c7680d48">here</a> and <a href="http://bl.ocks.org/sdjacobs/c2ee01307cdeceb19f9d">here</a>.</p>

</div>
